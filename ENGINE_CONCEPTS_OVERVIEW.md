# ENGINE_CONCEPTS_OVERVIEW — 문서 시각화 엔진 개념 정리

이 문서는 **문서 시각화 엔진의 개념·구조·UI·데이터 방향**을 마인드맵 3개 내용을 바탕으로 통합 정리한 것이다.  
(`통합 레이아웃 시스템`, `WYSIWYG Layout System Architecture`, `WYSIWYG Freeplane Advanced` 기반)

이 문서를 읽으면, 코드 작성 시 다음을 항상 기준으로 삼아야 한다.

- 무엇을(Section / Container / Module 등) 다루는 엔진인지  
- 레이아웃 구조를 어떻게 나눌지  
- UI가 어떤 모양과 동작을 가져야 하는지  
- 데이터(JSON)가 어떤 방향으로 설계돼야 하는지  
- 스냅샷/테스트/롤백 구조가 왜 중요한지  

---

## 1. 전체 목표 개념

1. **문서 시각화 엔진**은 텍스트 기반 문서를  
   - Section / Container / Grid/Flex / Module 단위로 구조화하고  
   - WYSIWYG 화면에 자동 배치한 뒤  
   - 사람이 직접 편집/보완할 수 있게 하는 도구이다.   

2. 엔진의 역할은 크게 네 가지다.
   - (1) **레이아웃 개념 정의**: Section·Container·Grid·Module·Spacing·Auto Layout 등 개념을 정리하고, 일관된 규칙으로 사용.
   - (2) **UI 에디터 제공**: 좌측 패널(구성요소), 중앙 캔버스(실제 화면), 우측 속성 패널(자세한 설정) 구조의 WYSIWYG 에디터. 
   - (3) **레이아웃 엔진**: JSON 기반 데이터 구조를 해석해서 DOM 레이아웃을 만들고, Spacing 규칙/반응형 규칙/Auto Layout을 적용.
   - (4) **저장·복원·배포**: JSON 스키마로 저장하고, 다시 복원하며, 최종 HTML/CSS로 배포.   

3. 이 엔진은 **Freeplane/FreeMind 마인드맵을 “설계 원본”으로 사용**하며,  
   구현된 코드는 항상 마인드맵 구조와 개념을 따라가야 한다.   

---

## 2. 레이아웃 도메인 개념

### 2.1 Section

- **정의**: 페이지 상의 최상위 블록. 하나의 페이지는 여러 개의 Section으로 구성된다.
- **역할**
  - 페이지 가로 폭의 기본 단위.
  - 각 Section은 폭과 정렬을 가진다.
- **속성 방향**
  - width: `"100%"` 또는 `"고정폭(px)"` (예: `500px`, `800px`)   
  - align: `"center" | "left" | "right"`
  - padding / margin: 내부·외부 여백을 가진다.
- **중요 규칙**
  - 섹션 내부 여백과 컨테이너 외부 여백이 충돌할 때, **상위(Section) 기준으로 자동 정리**한다. :contentReference[oaicite:5]{index=5}  

### 2.2 Container

- **정의**: 폭 제어 및 그룹화 단위. Section 안에 위치한다.
- **역할**
  - max-width 설정 (예: 본문 폭 800px).
  - 세로 방향으로 스택형(위→아래)으로 쌓이는 기본 구조. :contentReference[oaicite:6]{index=6}  
- **특징**
  - 중첩 가능 (Container 안에 또 Container)   
  - Grid/Flex의 “부모” 역할을 할 수 있음.
- **중요 개념**
  - **컨테이너 간격(Container Gap)**: 여러 컨테이너 사이 간격을 한 번에 제어할 수 있는 개념이 필요하다(다중 선택 포함). :contentReference[oaicite:8]{index=8}  

### 2.3 Grid & Flex (Row/Cell은 내부 개념으로 숨김)

- **Grid**
  - 가로 방향 분할 레이아웃 (n분할 구조)   
  - 각 칸(Cell)은 자동 비율 조정.
- **Flex**
  - 방향 기반 정렬(가로/세로), 정렬·정렬축·gap 제어.   
- **디자인 방향**
  - 내부적으로는 Row/Cell 개념이 있더라도,  
    **사용자에게는 “컨테이너 + 분할 옵션” 정도만 노출**하고 싶다.  
    (Row/Cell 용어를 굳이 UI에 드러내지 않는 방향) :contentReference[oaicite:11]{index=11}  

### 2.4 Module 시스템

- **정의**: 재사용 가능한 콘텐츠 블록.
- **주요 모듈 타입**
  - Text: 제목(대/중/소), 본문, 캡션   
  - Image: cover / contain / fill / 비율 유지   
  - Video: iframe 임베드, 자동 크기 조절
  - Table: 표
  - Composite: 카드·리스트·갤러리 등 반복 구조   
- **공통 속성**
  - 정렬, 여백, 스타일(색, 폰트, 테두리 등) 공통 속성 세트.   

### 2.5 Spacing 엔진

- **역할**
  - 상·하·좌·우 여백 규칙을 일관되게 제어.
  - margin-collapse 문제 방지, 충돌 방지 로직 포함.   
- **핵심 규칙**
  - **상위 여백 우선 규칙**: 상위 레벨(Section/Container)의 여백이 우선.   
  - Grid Gap / Flex Gap을 데이터 구조 상에 분리해서 관리.
  - 자동 충돌 방지 알고리즘(겹치거나 중복된 여백 제거).  

### 2.6 Auto Layout

- **개념**
  - Figma 스타일 Auto Layout처럼,  
    콘텐츠 길이/비율에 따라 자동으로 크기·정렬·분배를 계산하는 알고리즘.   
- **적용 대상**
  - 텍스트/이미지 혼합 레이아웃
  - 반복 카드/리스트
  - 반응형 폭 변화 시 재정렬
- **주의**
  - 자동 배치 vs 수동 조작이 충돌할 때의 우선순위 규칙이 반드시 필요.   

---

## 3. UI / UX 개념

### 3.1 전체 레이아웃

에디터 화면은 크게 세 영역으로 나뉜다.   

1. **좌측 패널**
   - 섹션/컨테이너/모듈 목록
   - 템플릿, 카드, 프리셋 레이아웃
2. **중앙 캔버스**
   - 실제 페이지 렌더링 영역
   - 직접 드래그/드롭/선택/크기 조절
3. **우측 속성 패널**
   - 선택된 요소의 세부 속성(폭, 여백, 정렬, 색, 모듈 속성 등) 편집 :contentReference[oaicite:21]{index=21}  

### 3.2 편집 모드 / 미리보기 모드

- Edit Mode
  - 모든 편집 핸들, 가이드라인, 드래그 핸들이 활성화.
- View Mode
  - 실제 배포본과 유사한 모습으로 보여줌.
  - 편집용 UI(테두리, 핸들 등)는 숨김.   

### 3.3 속성 패널 vs 직접 조작 기준

- **직접 조작(캔버스 위에서)**
  - 크기 조절, 위치 이동, 분할/병합 정도의 빠른 작업.  
- **속성 패널**
  - 정확한 수치 입력, 정렬 방식, Auto Layout 옵션, 고급 설정 등.   

이 “어떤 것은 패널에서, 어떤 것은 직접 드래그로 조정할지”에 대한 기준이 중요하며,  
UI/UX 설계 시 이 기준을 문서화하고 코드에도 반영해야 한다. :contentReference[oaicite:24]{index=24}  

### 3.4 기타 UI 요소

- PC/Tablet/Mobile 미리보기 토글(반응형 확인) :contentReference[oaicite:25]{index=25}  
- Undo/Redo 스택
- 다중 선택 및 그룹 편집
- 플로팅 미니 속성 패널 (간단 옵션만 빠르게 수정)   

---

## 4. 시스템 아키텍처 레이어

마인드맵 기준, 전체 시스템은 다음과 같은 레이어로 나뉜다.   

1. **클라이언트 애플리케이션 레이어**
   - 브라우저 기반 SPA(React/Vue 등) 구조.
   - 에디터 UI, 미리보기, 단축키, 드래그 앤 드롭 이벤트 처리.

2. **에디터 UI & 상태(State) 관리**
   - 전역 상태(Store): 선택 요소, 모드, 줌 비율.
   - Undo/Redo 스택.
   - 모드 전환 시 UI 숨김/표시 로직.

3. **레이아웃 엔진**
   - Section / Container / Grid/Flex 관리.
   - 여백 충돌 방지 알고리즘.
   - 반응형 레이아웃 규칙.

4. **모듈 & 콘텐츠 엔진**
   - 텍스트/이미지/비디오/카드/리스트 등의 렌더링 및 속성 적용.
   - 모듈 공통 스타일 시스템.

5. **시각화 & 자동 레이아웃 엔진**
   - 텍스트 구조 분석 → 레이아웃 자동 제안.
   - 이미지·텍스트 혼합 자동 배치.   

6. **저장·로드·버전 관리**
   - JSON 스키마 설계.
   - Draft / Published 버전 분리.
   - 자동 저장 및 충돌 처리.
   - 버전 히스토리 관리.

7. **렌더링 & 배포 파이프라인**
   - JSON → DOM 미리보기 렌더러.
   - 편집 요소 제거된 최종 HTML/CSS 출력.
   - 외부 CMS/쇼핑몰/블로그 연동, CDN 배포.

8. **사용자 / 권한 / 협업 시스템 (후순위)**
   - 계정/역할 관리, 권한 분리, 승인 워크플로우.

9. **플러그인 & 확장**
   - 모듈 플러그인, 속성 패널 확장 포인트, 테마/스타일 프리셋. :contentReference[oaicite:29]{index=29}  

10. **로깅·모니터링·성능**
    - 에러 및 행동 로그, 성능 모니터링, 대용량 문서 처리 등.

---

## 5. 스냅샷/테스트/버전 구조

마인드맵에서 강조한 것 중 매우 중요한 부분:  
**“잘못된 방향으로 갔을 때 되돌아올 수 있어야 한다”**는 점이다.   

- **스냅샷(Snapshot)**
  - 특정 시점의 전체 레이아웃 JSON을 저장.
  - “왜 이 스냅샷을 찍었는지”에 대한 메모를 남김.
- **테스트샷(Test Shot)**
  - 실험용 레이아웃 (새로운 규칙 적용 전후 비교).
- **롤백 구조**
  - 문제가 생기면 이전 스냅샷으로 쉽게 되돌릴 수 있어야 함.

프로젝트 폴더 구조 관점에서:

- `/2_snapshots/` 폴더: 시간+설명 기반 파일명으로 JSON 저장.
- `/3_projects/engine_v0/` : 안정된 엔진 코드.
- 실험용은 `engine_experiment` 또는 별도 브랜치로 관리.

---

## 6. ChatGPT / Codex / Freeplane 협업 규칙

1. **Freeplane 마인드맵**
   - 모든 개념과 플랜의 “시각적/트리식 원본”.
   - 큰 방향을 바꾸기 전에 마인드맵부터 수정.

2. **ChatGPT**
   - 마인드맵 내용을 텍스트 규칙/문서/코드 설계로 변환.
   - 개념 정리, 지침서, 스키마 정의, 의사결정 기록 담당. :contentReference[oaicite:31]{index=31}  

3. **Codex (VSCode)**
   - 이 문서와 PROJECT_RULES_SUMMARY.md를 기준으로 코드를 생성·수정.
   - 항상 `0_docs/*.md`에 기록된 규칙을 우선적으로 따름.

4. **GitHub**
   - Master / Snapshot / Test 브랜치 구조로 버전 관리.
   - README 및 문서 자동 업데이트는 장기적으로 구현. :contentReference[oaicite:32]{index=32}  

---

## 7. 이 문서를 읽고 Codex가 가져야 하는 상태

- 이 엔진이 **“문서를 레이아웃 단위로 쪼개서 WYSIWYG로 보여주는 시스템”**이라는 것을 이해할 것.
- Section / Container / Module / Spacing / Auto Layout / Snapshot 등 **핵심 개념의 역할**을 알고 있을 것.
- UI가 **좌측 패널 / 중앙 캔버스 / 우측 속성 패널** 구조라는 것을 알고 있을 것.
- 레이아웃 데이터는 **JSON 구조로 저장되고, layout-schema.json으로 스키마가 정리될 것**이라는 방향을 알고 있을 것.
- 잘못된 방향으로 갔을 때를 대비한 **스냅샷/테스트/롤백 구조가 필수 요건**이라는 것을 인지할 것.

이 문서는 코드가 아니라 **코드가 어떤 방향으로 가야 하는지에 대한 “지도”** 역할을 한다.  
코드를 쓸 때마다, 이 문서와 `PROJECT_RULES_SUMMARY.md`를 함께 참고해야 한다.
